1.工程以原生native端为载体，RN以bundle包形式嵌入；
2.目前全局监听的字段，涉及登录方面为字符串字面量，而其他一些例如页面，token等则为原生模块的变量（通过RN的NativeModule定义的YMShopSDK）；
3.主入口app.js，引入了版本管理、基础配置（身份监听处理，涉及native端）、主路由及其跳转管理RouterMapper；
4.打开纯RN页面，使用native或者flux的Actions跳转；
5.小细节：页面跳转或者打开容器的回调方法，放在监听回调中，等待登录状态更新后再触发；
6.从整体上看，项目大部分动作建立在用户数据刷新回调上；
7.页面跳转方式新增了纯RN监听原生emit字段而进行Actions跳转；
8.难点：native端、路由和mobx；（需要攻克的）;
9.项目基础base包（native_modules文件夹，ym-base，ym-http和ym-native-base）；
10.高阶组件包裹，返回的组件实例是在wrappedInstance属性中；
11.新增路由跳转页面需要继承BasePage，并且需要调用getRealComponent方法来保存target（ref），以便继承的各种路由回调能找到相应的ref；
12.Reducer定义为纯函数，用于处理旧state（结合action）以得新state。里面涉及的思想也不少，后续有机会可以抽空了解一下redux；
13.思想很重要，对项目熟悉和诞生很有帮助。学习曲线很抖；
14.每个reducer只负责管理处理state的一部分，而且入参都不同，以保持独立性来专门处理不同的数据域；
15.Reducer思想部分类似逻辑层，干净，无副作用，专门进行数据处理；

路由相关
1.MainRouter模块做了什么？
(1)使用了react-native-router-flux库，引用了Actions、Router、Reducer和Scene；
(2)大头在Router的onStateChange和createReducer方法。当路由切换时，通过回调可以获取当前路由栈的相关信息，例如routeName、index和key等，在里面可以做埋点以及调用实例方法；
(3)管理路由实例是通过对象值键对形式保存在类变量中；
2.RouterMapper:
(1)导出全局的一个实例类对象，内部核心是注册监听器_registerListener（内部方法），监听登录状态字段，然后根据传入的参数解析anctionId，判断是否纯RN再调用Actions或者Native.openPureRN（）；
(2)向外暴露jump方法，接收跳转参数。注册监听器，然后刷新登录状态；
3.WidgetActionMapper：
(1)在RouterMapper基础上封装的类，通过调用RouterMapper的jump方法来实现页面跳转；
(2)并非两个独立的路由控制器；

依赖相关
1.项目依赖搭建基本围绕react、react-native、axios、mobx、react-native-router-flux、eslint、babel-eslint等；
2.基本配置有husky、patch-package（打补丁）等；
1.WidgetContainer使用了wrapWidget方法创建了高阶组件，通过inject（XXX）（observer（class XXX extends XXX））方法全局注入公共store；
2.wrapWidget方法内部统一为组件item处理了外容器的背景色等，根据是否需要渲染组件来控制调用super.render（）或者return 空View；
3.WidgetContainer是最为核心的组件之一，具备功用性；内部通过外部props渲染各种配置的item组件（通过wrapWidget包裹），包含刷新头header；
4.思想是由外部数据控制渲染；
5.核心组件大多导出同时都有使用es6和commonJS导出，保证兼容性；